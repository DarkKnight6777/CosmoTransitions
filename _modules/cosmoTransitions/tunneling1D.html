<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>cosmoTransitions.tunneling1D &#8212; CosmoTransitions 2.0.2 documentation</title>
    
    <link rel="stylesheet" href="../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '2.0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">CosmoTransitions 2.0.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for cosmoTransitions.tunneling1D</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module (along with a few functions in :mod:`.helper_functions`) contains</span>
<span class="sd">everything that is needed to calculate instantons in one field dimension.</span>
<span class="sd">The primary class is :class:`SingleFieldInstanton`, which can calculate the</span>
<span class="sd">instanton solution in any number of spatial dimensions using the overshoot /</span>
<span class="sd">undershoot method. Additional classes inherit common functionality from this</span>
<span class="sd">one, and can be used to calculate the bubble wall profile with constant</span>
<span class="sd">friction (:class:`WallWithConstFriction`) instead of radius-dependent friction,</span>
<span class="sd">or to calculate the instanton in the presence of gravity (*not yet</span>
<span class="sd">implemented*).</span>

<span class="sd">.. todo::</span>
<span class="sd">    Create and document a *CDL_Instanton* class for tunneling with gravity.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">optimize</span><span class="p">,</span> <span class="n">integrate</span><span class="p">,</span> <span class="n">special</span><span class="p">,</span> <span class="n">interpolate</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">namedtuple</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">helper_functions</span>
<span class="kn">from</span> <span class="nn">.helper_functions</span> <span class="k">import</span> <span class="n">rkqs</span><span class="p">,</span> <span class="n">IntegrationError</span><span class="p">,</span> <span class="n">clampVal</span>
<span class="kn">from</span> <span class="nn">.helper_functions</span> <span class="k">import</span> <span class="n">cubicInterpFunction</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span>
    <span class="n">xrange</span> <span class="o">=</span> <span class="nb">range</span>


<div class="viewcode-block" id="PotentialError"><a class="viewcode-back" href="../../tunnelling1D.html#cosmoTransitions.tunneling1D.PotentialError">[docs]</a><span class="k">class</span> <span class="nc">PotentialError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Used when the potential does not have the expected characteristics.</span>

<span class="sd">    The error messages should be tuples, with the second item being one of</span>
<span class="sd">    ``(&quot;no barrier&quot;, &quot;stable, not metastable&quot;)``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="SingleFieldInstanton"><a class="viewcode-back" href="../../tunnelling1D.html#cosmoTransitions.tunneling1D.SingleFieldInstanton">[docs]</a><span class="k">class</span> <span class="nc">SingleFieldInstanton</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class will calculate properties of an instanton with a single scalar</span>
<span class="sd">    Field without gravity using the overshoot/undershoot method.</span>

<span class="sd">    Most users will probably be primarily interested in the functions</span>
<span class="sd">    :func:`findProfile` and :func:`findAction`.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    When the bubble is thin-walled (due to nearly degenerate minima), an</span>
<span class="sd">    approximate solution is found to the equations of motion and integration</span>
<span class="sd">    starts close to the wall itself (instead of always starting at the center</span>
<span class="sd">    of the bubble). This way the overshoot/undershoot method runs just as fast</span>
<span class="sd">    for extremely thin-walled bubbles as it does for thick-walled bubbles.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    phi_absMin : float</span>
<span class="sd">        The field value at the stable vacuum to which the instanton</span>
<span class="sd">        tunnels. Nowhere in the code is it *required* that there actually be a</span>
<span class="sd">        minimum at `phi_absMin`, but the :func:`findProfile` function will only</span>
<span class="sd">        use initial conditions between `phi_absMin` and `phi_metaMin`, and the</span>
<span class="sd">        code is optimized for thin-walled bubbles when the center of the</span>
<span class="sd">        instanton is close to `phi_absMin`.</span>
<span class="sd">    phi_metaMin : float</span>
<span class="sd">        The field value in the metastable vacuum.</span>
<span class="sd">    V : callable</span>
<span class="sd">        The potential function. It should take as its single parameter the field</span>
<span class="sd">        value `phi`.</span>
<span class="sd">    dV, d2V : callable, optional</span>
<span class="sd">        The potential&#39;s first and second derivatives. If not None, these</span>
<span class="sd">        override the methods :func:`dV` and :func:`d2V`.</span>
<span class="sd">    phi_eps : float, optional</span>
<span class="sd">        A small value used to calculate derivatives (if not overriden by</span>
<span class="sd">        the user) and in the function :func:`dV_from_absMin`. The input should</span>
<span class="sd">        be unitless; it is later rescaled by ``abs(phi_absMin - phi_metaMin)``.</span>
<span class="sd">    alpha : int or float, optional</span>
<span class="sd">        The coefficient for the friction term in the ODE. This is also</span>
<span class="sd">        the number of spacetime dimensions minus 1.</span>
<span class="sd">    phi_bar : float, optional</span>
<span class="sd">        The field value at the edge of the barrier. If `None`, it is found by</span>
<span class="sd">        :func:`findBarrierLocation`.</span>
<span class="sd">    rscale : float, optional</span>
<span class="sd">        The approximate radial scale of the instanton. If `None` it is found by</span>
<span class="sd">        :func:`findRScale`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    PotentialError</span>
<span class="sd">        when the barrier is non-existent or when the presumably stable minimum</span>
<span class="sd">        has a higher energy that the metastable minimum.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Thick and thin-walled bubbles:</span>

<span class="sd">    .. plot::</span>
<span class="sd">        :include-source:</span>

<span class="sd">        from cosmoTransitions.tunneling1D import SingleFieldInstanton</span>
<span class="sd">        import matplotlib.pyplot as plt</span>

<span class="sd">        # Thin-walled</span>
<span class="sd">        def V1(phi): return 0.25*phi**4 - 0.49*phi**3 + 0.235 * phi**2</span>
<span class="sd">        def dV1(phi): return phi*(phi-.47)*(phi-1)</span>
<span class="sd">        profile = SingleFieldInstanton(1.0, 0.0, V1, dV1).findProfile()</span>
<span class="sd">        plt.plot(profile.R, profile.Phi)</span>

<span class="sd">        # Thick-walled</span>
<span class="sd">        def V2(phi): return 0.25*phi**4 - 0.4*phi**3 + 0.1 * phi**2</span>
<span class="sd">        def dV2(phi): return phi*(phi-.2)*(phi-1)</span>
<span class="sd">        profile = SingleFieldInstanton(1.0, 0.0, V2, dV2).findProfile()</span>
<span class="sd">        plt.plot(profile.R, profile.Phi)</span>

<span class="sd">        plt.xlabel(r&quot;Radius $r$&quot;)</span>
<span class="sd">        plt.ylabel(r&quot;Field $\phi$&quot;)</span>
<span class="sd">        plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi_absMin</span><span class="p">,</span> <span class="n">phi_metaMin</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span>
                 <span class="n">dV</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">d2V</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">phi_eps</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                 <span class="n">phi_bar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rscale</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi_absMin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_metaMin</span> <span class="o">=</span> <span class="n">phi_absMin</span><span class="p">,</span> <span class="n">phi_metaMin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="n">V</span>
        <span class="k">if</span> <span class="n">V</span><span class="p">(</span><span class="n">phi_metaMin</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">V</span><span class="p">(</span><span class="n">phi_absMin</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">PotentialError</span><span class="p">(</span><span class="s2">&quot;V(phi_metaMin) &lt;= V(phi_absMin); &quot;</span>
                                 <span class="s2">&quot;tunneling cannot occur.&quot;</span><span class="p">,</span> <span class="s2">&quot;stable, not metastable&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dV</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dV</span> <span class="o">=</span> <span class="n">dV</span>
        <span class="k">if</span> <span class="n">d2V</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">d2V</span> <span class="o">=</span> <span class="n">d2V</span>
        <span class="k">if</span> <span class="n">phi_bar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">phi_bar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findBarrierLocation</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">phi_bar</span> <span class="o">=</span> <span class="n">phi_bar</span>
        <span class="k">if</span> <span class="n">rscale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rscale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findRScale</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rscale</span> <span class="o">=</span> <span class="n">rscale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi_eps</span> <span class="o">=</span> <span class="n">phi_eps</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">phi_absMin</span> <span class="o">-</span> <span class="n">phi_metaMin</span><span class="p">)</span>

<div class="viewcode-block" id="SingleFieldInstanton.dV"><a class="viewcode-back" href="../../tunnelling1D.html#cosmoTransitions.tunneling1D.SingleFieldInstanton.dV">[docs]</a>    <span class="k">def</span> <span class="nf">dV</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">):</span>
        <span class="sd">R&quot;&quot;&quot;</span>
<span class="sd">        Calculates `dV/dphi` using finite differences.</span>

<span class="sd">        The finite difference is given by `self.phi_eps`, and the derivative</span>
<span class="sd">        is calculated to fourth order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_eps</span>
        <span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">V</span><span class="p">(</span><span class="n">phi</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">eps</span><span class="p">)</span> <span class="o">-</span> <span class="mi">8</span><span class="o">*</span><span class="n">V</span><span class="p">(</span><span class="n">phi</span><span class="o">-</span><span class="n">eps</span><span class="p">)</span> <span class="o">+</span> <span class="mi">8</span><span class="o">*</span><span class="n">V</span><span class="p">(</span><span class="n">phi</span><span class="o">+</span><span class="n">eps</span><span class="p">)</span> <span class="o">-</span> <span class="n">V</span><span class="p">(</span><span class="n">phi</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">eps</span><span class="p">)</span>
                <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">12.</span><span class="o">*</span><span class="n">eps</span><span class="p">)</span></div>

<div class="viewcode-block" id="SingleFieldInstanton.dV_from_absMin"><a class="viewcode-back" href="../../tunnelling1D.html#cosmoTransitions.tunneling1D.SingleFieldInstanton.dV_from_absMin">[docs]</a>    <span class="k">def</span> <span class="nf">dV_from_absMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta_phi</span><span class="p">):</span>
        <span class="sd">R&quot;&quot;&quot;</span>
<span class="sd">        Calculates `dV/dphi` at ``phi = phi_absMin + delta_phi``.</span>

<span class="sd">        It is sometimes helpful to find `dV/dphi` extremely close to the</span>
<span class="sd">        minimum. In this case, floating-point error can be significant. To get</span>
<span class="sd">        increased accuracy, this function expands about the minimum in</span>
<span class="sd">        a Taylor series and uses that for nearby values. That is,</span>
<span class="sd">        :math:`V&#39;(\phi) \approx V&#39;&#39;(\phi_{\rm absMin})(\phi-\phi_{\rm absMin})`.</span>
<span class="sd">        For values that are farther away, it instead uses :func:`dV`.</span>
<span class="sd">        It blends the two methods so that there are no numerical</span>
<span class="sd">        discontinuities.</span>

<span class="sd">        This uses `self.phi_eps` to determine whether the field is considered</span>
<span class="sd">        nearby or not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_absMin</span> <span class="o">+</span> <span class="n">delta_phi</span>
        <span class="n">dV</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dV</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
        <span class="c1"># If phi is very close to phi_absMin, it should be safer to assume</span>
        <span class="c1"># that dV is zero exactly at phi_absMin and instead calculate dV from</span>
        <span class="c1"># d2V.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_eps</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dV_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d2V</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">delta_phi</span>
            <span class="c1"># blend the two together so that there are no discontinuites</span>
            <span class="n">blend_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">delta_phi</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_eps</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">dV</span> <span class="o">=</span> <span class="n">dV_</span><span class="o">*</span><span class="n">blend_factor</span> <span class="o">+</span> <span class="n">dV</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">blend_factor</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dV</span></div>

<div class="viewcode-block" id="SingleFieldInstanton.d2V"><a class="viewcode-back" href="../../tunnelling1D.html#cosmoTransitions.tunneling1D.SingleFieldInstanton.d2V">[docs]</a>    <span class="k">def</span> <span class="nf">d2V</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">):</span>
        <span class="sd">R&quot;&quot;&quot;</span>
<span class="sd">        Calculates `d^2V/dphi^2` using finite differences.</span>

<span class="sd">        The finite difference is given by `self.phi_eps`, and the derivative</span>
<span class="sd">        is calculated to fourth order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_eps</span>
        <span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">V</span><span class="p">(</span><span class="n">phi</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">eps</span><span class="p">)</span> <span class="o">+</span> <span class="mi">16</span><span class="o">*</span><span class="n">V</span><span class="p">(</span><span class="n">phi</span><span class="o">-</span><span class="n">eps</span><span class="p">)</span> <span class="o">-</span> <span class="mi">30</span><span class="o">*</span><span class="n">V</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
                <span class="o">+</span> <span class="mi">16</span><span class="o">*</span><span class="n">V</span><span class="p">(</span><span class="n">phi</span><span class="o">+</span><span class="n">eps</span><span class="p">)</span> <span class="o">-</span> <span class="n">V</span><span class="p">(</span><span class="n">phi</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">eps</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mf">12.</span><span class="o">*</span><span class="n">eps</span><span class="o">*</span><span class="n">eps</span><span class="p">)</span></div>

<div class="viewcode-block" id="SingleFieldInstanton.findBarrierLocation"><a class="viewcode-back" href="../../tunnelling1D.html#cosmoTransitions.tunneling1D.SingleFieldInstanton.findBarrierLocation">[docs]</a>    <span class="k">def</span> <span class="nf">findBarrierLocation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">R&quot;&quot;&quot;</span>
<span class="sd">        Find edge of the potential barrier.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        phi_barrier : float</span>
<span class="sd">            The value such that `V(phi_barrier) = V(phi_metaMin)`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">phi_tol</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_metaMin</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_absMin</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">12</span>
        <span class="n">V_phimeta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_metaMin</span><span class="p">)</span>
        <span class="n">phi1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_metaMin</span>
        <span class="n">phi2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_absMin</span>
        <span class="n">phi0</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">phi1</span><span class="o">+</span><span class="n">phi2</span><span class="p">)</span>

        <span class="c1"># Do a very simple binary search to narrow down on the right answer.</span>
        <span class="k">while</span> <span class="nb">abs</span><span class="p">(</span><span class="n">phi1</span><span class="o">-</span><span class="n">phi2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">phi_tol</span><span class="p">:</span>
            <span class="n">V0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">(</span><span class="n">phi0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">V0</span> <span class="o">&gt;</span> <span class="n">V_phimeta</span><span class="p">:</span>
                <span class="n">phi1</span> <span class="o">=</span> <span class="n">phi0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">phi2</span> <span class="o">=</span> <span class="n">phi0</span>
            <span class="n">phi0</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">phi1</span><span class="o">+</span><span class="n">phi2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">phi0</span></div>

<div class="viewcode-block" id="SingleFieldInstanton.findRScale"><a class="viewcode-back" href="../../tunnelling1D.html#cosmoTransitions.tunneling1D.SingleFieldInstanton.findRScale">[docs]</a>    <span class="k">def</span> <span class="nf">findRScale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">R&quot;&quot;&quot;</span>
<span class="sd">        Find the characteristic length scale for tunneling over the potential</span>
<span class="sd">        barrier.</span>

<span class="sd">        The characteristic length scale should formally be given by the period</span>
<span class="sd">        of oscillations about the top of the potential barrier. However, it is</span>
<span class="sd">        perfectly acceptable for the potential barrier to have a flat top, in</span>
<span class="sd">        which case a naive calculation of the length scale would be infinite.</span>
<span class="sd">        Instead, this function finds the top of the barrier along with a cubic</span>
<span class="sd">        function that has a maximum at the barrier top and a minimum at the</span>
<span class="sd">        metastable minimum. The returned length scale is then the period of</span>
<span class="sd">        oscillations about this cubic maximum.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        PotentialError</span>
<span class="sd">            when the barrier is non-existent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        NOT USED:</span>
<span class="sd">        We could also do a sanity check in case the barrier goes to zero.</span>
<span class="sd">        A second way of finding the scale is to see how long it would take</span>
<span class="sd">        the field to roll from one minimum to the other if the potential were</span>
<span class="sd">        purely linear and there were no friction.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        second_check : float</span>
<span class="sd">            If bigger than zero, do the sanity check. Return value is then the</span>
<span class="sd">            larger of the first scale and the second scale times</span>
<span class="sd">            `second_check`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">phi_tol</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_bar</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_metaMin</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">6</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_bar</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_metaMin</span><span class="p">)</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_bar</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_metaMin</span><span class="p">)</span>
        <span class="n">phi_bar_top</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">fminbound</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">xtol</span><span class="o">=</span><span class="n">phi_tol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">phi_bar_top</span> <span class="o">+</span> <span class="n">phi_tol</span> <span class="o">&gt;</span> <span class="n">x2</span> <span class="ow">or</span> <span class="n">phi_bar_top</span> <span class="o">-</span> <span class="n">phi_tol</span> <span class="o">&lt;</span> <span class="n">x1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">PotentialError</span><span class="p">(</span>
                <span class="s2">&quot;Minimization is placing the top of the &quot;</span>
                <span class="s2">&quot;potential barrier outside of the interval defined by &quot;</span>
                <span class="s2">&quot;phi_bar and phi_metaMin. Assume that the barrier does not exist.&quot;</span><span class="p">,</span>
                <span class="s2">&quot;no barrier&quot;</span><span class="p">)</span>

        <span class="n">Vtop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">(</span><span class="n">phi_bar_top</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_metaMin</span><span class="p">)</span>
        <span class="n">xtop</span> <span class="o">=</span> <span class="n">phi_bar_top</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_metaMin</span>
        <span class="c1"># Cubic function given by (ignoring linear and constant terms):</span>
        <span class="c1"># f(x) = C [(-1/3)x^3 + (1/2)x^2 xtop]</span>
        <span class="c1"># C = 6 Vtop / xtop^3</span>
        <span class="c1"># f&#39;&#39;(xtop) = - C xtop</span>
        <span class="c1"># d2V = -6*Vtop / xtop**2</span>
        <span class="c1"># rscale = 1 / sqrt(d2V)</span>
        <span class="k">if</span> <span class="n">Vtop</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">PotentialError</span><span class="p">(</span><span class="s2">&quot;Barrier height is not positive, &quot;</span>
                                 <span class="s2">&quot;does not exist.&quot;</span><span class="p">,</span> <span class="s2">&quot;no barrier&quot;</span><span class="p">)</span>
        <span class="n">rscale1</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">xtop</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="mi">6</span><span class="o">*</span><span class="n">Vtop</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">rscale1</span>
        <span class="c1"># The following would calculate it a separate way, but this goes</span>
        <span class="c1"># to infinity when delta_V goes to zero, so it&#39;s a bad way of doing it</span>
        <span class="n">delta_phi</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_absMin</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_metaMin</span><span class="p">)</span>
        <span class="n">delta_V</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_absMin</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_metaMin</span><span class="p">))</span>
        <span class="n">rscale2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">delta_phi</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">delta_V</span><span class="o">+</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">100</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">rscale1</span><span class="p">,</span> <span class="n">rscale2</span><span class="p">)</span></div>

    <span class="n">_exactSolution_rval</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;exactSolution_rval&quot;</span><span class="p">,</span> <span class="s2">&quot;phi dphi&quot;</span><span class="p">)</span>
<div class="viewcode-block" id="SingleFieldInstanton.exactSolution"><a class="viewcode-back" href="../../tunnelling1D.html#cosmoTransitions.tunneling1D.SingleFieldInstanton.exactSolution">[docs]</a>    <span class="k">def</span> <span class="nf">exactSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">phi0</span><span class="p">,</span> <span class="n">dV</span><span class="p">,</span> <span class="n">d2V</span><span class="p">):</span>
        <span class="sd">R&quot;&quot;&quot;</span>
<span class="sd">        Find `phi(r)` given `phi(r=0)`, assuming a quadratic potential.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        r : float</span>
<span class="sd">            The radius at which the solution should be calculated.</span>
<span class="sd">        phi0 : float</span>
<span class="sd">            The field at `r=0`.</span>
<span class="sd">        dV, d2V : float</span>
<span class="sd">            The potential&#39;s first and second derivatives evaluated at `phi0`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        phi, dphi : float</span>
<span class="sd">            The field and its derivative evaluated at `r`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        If the potential at the point :math:`\phi_0` is a simple quadratic, the</span>
<span class="sd">        solution to the instanton equation of motion can be determined exactly.</span>
<span class="sd">        The non-singular solution to</span>

<span class="sd">        .. math::</span>
<span class="sd">          \frac{d^2\phi}{dr^2} + \frac{\alpha}{r}\frac{d\phi}{dr} =</span>
<span class="sd">          V&#39;(\phi_0) + V&#39;&#39;(\phi_0) (\phi-\phi_0)</span>

<span class="sd">        is</span>

<span class="sd">        .. math::</span>
<span class="sd">          \phi(r)-\phi_0 = \frac{V&#39;}{V&#39;&#39;}\left[</span>
<span class="sd">          \Gamma(\nu+1)\left(\frac{\beta r}{2}\right)^{-\nu} I_\nu(\beta r) - 1</span>
<span class="sd">          \right]</span>

<span class="sd">        where :math:`\nu = \frac{\alpha-1}{2}`, :math:`I_\nu` is the modified</span>
<span class="sd">        Bessel function, and :math:`\beta^2 = V&#39;&#39;(\phi_0) &gt; 0`. If instead</span>
<span class="sd">        :math:`-\beta^2 = V&#39;&#39;(\phi_0) &lt; 0`, the solution is the same but with</span>
<span class="sd">        :math:`I_\nu \rightarrow J_\nu`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">d2V</span><span class="p">))</span>
        <span class="n">beta_r</span> <span class="o">=</span> <span class="n">beta</span><span class="o">*</span><span class="n">r</span>
        <span class="n">nu</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="n">special</span><span class="o">.</span><span class="n">gamma</span>  <span class="c1"># Gamma function</span>
        <span class="n">iv</span><span class="p">,</span> <span class="n">jv</span> <span class="o">=</span> <span class="n">special</span><span class="o">.</span><span class="n">iv</span><span class="p">,</span> <span class="n">special</span><span class="o">.</span><span class="n">jv</span>  <span class="c1"># (modified) Bessel function</span>
        <span class="k">if</span> <span class="n">beta_r</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Use a small-r approximation for the Bessel function.</span>
            <span class="n">s</span> <span class="o">=</span> <span class="o">+</span><span class="mi">1</span> <span class="k">if</span> <span class="n">d2V</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">dphi</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">):</span>
                <span class="n">_</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">beta_r</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">s</span><span class="o">**</span><span class="n">k</span> <span class="o">/</span> <span class="p">(</span><span class="n">gamma</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">gamma</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">nu</span><span class="p">))</span>
                <span class="n">phi</span> <span class="o">+=</span> <span class="n">_</span>
                <span class="n">dphi</span> <span class="o">+=</span> <span class="n">_</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="p">)</span>
            <span class="n">phi</span> <span class="o">*=</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="n">gamma</span><span class="p">(</span><span class="n">nu</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dV</span> <span class="o">*</span> <span class="n">s</span>
            <span class="n">dphi</span> <span class="o">*=</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="n">gamma</span><span class="p">(</span><span class="n">nu</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">r</span> <span class="o">*</span> <span class="n">dV</span> <span class="o">*</span> <span class="n">s</span>
            <span class="n">phi</span> <span class="o">+=</span> <span class="n">phi0</span>
        <span class="k">elif</span> <span class="n">d2V</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">warnings</span>
            <span class="c1"># If beta_r is very large, this will throw off overflow and divide</span>
            <span class="c1"># by zero errors in iv(). It will return np.inf though, which is</span>
            <span class="c1"># what we want. Just ignore the warnings.</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
                <span class="n">phi</span> <span class="o">=</span> <span class="p">(</span><span class="n">gamma</span><span class="p">(</span><span class="n">nu</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">beta_r</span><span class="p">)</span><span class="o">**-</span><span class="n">nu</span> <span class="o">*</span> <span class="n">iv</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">beta_r</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dV</span><span class="o">/</span><span class="n">d2V</span>
                <span class="n">dphi</span> <span class="o">=</span> <span class="o">-</span><span class="n">nu</span><span class="o">*</span><span class="p">((</span><span class="mf">0.5</span><span class="o">*</span><span class="n">beta_r</span><span class="p">)</span><span class="o">**-</span><span class="n">nu</span> <span class="o">/</span> <span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="n">iv</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">beta_r</span><span class="p">)</span>
                <span class="n">dphi</span> <span class="o">+=</span> <span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">beta_r</span><span class="p">)</span><span class="o">**-</span><span class="n">nu</span> <span class="o">*</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">beta</span> \
                        <span class="o">*</span> <span class="p">(</span><span class="n">iv</span><span class="p">(</span><span class="n">nu</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">beta_r</span><span class="p">)</span><span class="o">+</span><span class="n">iv</span><span class="p">(</span><span class="n">nu</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">beta_r</span><span class="p">))</span>
                <span class="n">dphi</span> <span class="o">*=</span> <span class="n">gamma</span><span class="p">(</span><span class="n">nu</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dV</span><span class="o">/</span><span class="n">d2V</span>
                <span class="n">phi</span> <span class="o">+=</span> <span class="n">phi0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="p">(</span><span class="n">gamma</span><span class="p">(</span><span class="n">nu</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">beta_r</span><span class="p">)</span><span class="o">**-</span><span class="n">nu</span> <span class="o">*</span> <span class="n">jv</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">beta_r</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dV</span><span class="o">/</span><span class="n">d2V</span>
            <span class="n">dphi</span> <span class="o">=</span> <span class="o">-</span><span class="n">nu</span><span class="o">*</span><span class="p">((</span><span class="mf">0.5</span><span class="o">*</span><span class="n">beta_r</span><span class="p">)</span><span class="o">**-</span><span class="n">nu</span> <span class="o">/</span> <span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="n">jv</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">beta_r</span><span class="p">)</span>
            <span class="n">dphi</span> <span class="o">+=</span> <span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">beta_r</span><span class="p">)</span><span class="o">**-</span><span class="n">nu</span> <span class="o">*</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">beta</span> \
                    <span class="o">*</span> <span class="p">(</span><span class="n">jv</span><span class="p">(</span><span class="n">nu</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">beta_r</span><span class="p">)</span><span class="o">-</span><span class="n">jv</span><span class="p">(</span><span class="n">nu</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">beta_r</span><span class="p">))</span>
            <span class="n">dphi</span> <span class="o">*=</span> <span class="n">gamma</span><span class="p">(</span><span class="n">nu</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dV</span><span class="o">/</span><span class="n">d2V</span>
            <span class="n">phi</span> <span class="o">+=</span> <span class="n">phi0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exactSolution_rval</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">dphi</span><span class="p">)</span></div>

    <span class="n">_initialConditions_rval</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span>
        <span class="s2">&quot;initialConditions_rval&quot;</span><span class="p">,</span> <span class="s2">&quot;r0 phi dphi&quot;</span><span class="p">)</span>
<div class="viewcode-block" id="SingleFieldInstanton.initialConditions"><a class="viewcode-back" href="../../tunnelling1D.html#cosmoTransitions.tunneling1D.SingleFieldInstanton.initialConditions">[docs]</a>    <span class="k">def</span> <span class="nf">initialConditions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta_phi0</span><span class="p">,</span> <span class="n">rmin</span><span class="p">,</span> <span class="n">delta_phi_cutoff</span><span class="p">):</span>
        <span class="sd">R&quot;&quot;&quot;</span>
<span class="sd">        Finds the initial conditions for integration.</span>

<span class="sd">        The instanton equations of motion are singular at `r=0`, so we</span>
<span class="sd">        need to start the integration at some larger radius. This</span>
<span class="sd">        function finds the value `r0` such that `phi(r0) = phi_cutoff`.</span>
<span class="sd">        If there is no such value, it returns the intial conditions at `rmin`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        delta_phi0 : float</span>
<span class="sd">            `delta_phi0 = phi(r=0) - phi_absMin`</span>
<span class="sd">        rmin : float</span>
<span class="sd">            The smallest acceptable radius at which to start integration.</span>
<span class="sd">        delta_phi_cutoff : float</span>
<span class="sd">            The desired value for `phi(r0)`.</span>
<span class="sd">            `delta_phi_cutoff = phi(r0) - phi_absMin`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        r0, phi, dphi : float</span>
<span class="sd">            The initial radius and the field and its derivative at that radius.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The field values are calculated using :func:`exactSolution`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">phi0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_absMin</span> <span class="o">+</span> <span class="n">delta_phi0</span>
        <span class="n">dV</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dV_from_absMin</span><span class="p">(</span><span class="n">delta_phi0</span><span class="p">)</span>
        <span class="n">d2V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d2V</span><span class="p">(</span><span class="n">phi0</span><span class="p">)</span>
        <span class="n">phi_r0</span><span class="p">,</span> <span class="n">dphi_r0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exactSolution</span><span class="p">(</span><span class="n">rmin</span><span class="p">,</span> <span class="n">phi0</span><span class="p">,</span> <span class="n">dV</span><span class="p">,</span> <span class="n">d2V</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">phi_r0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_absMin</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">delta_phi_cutoff</span><span class="p">):</span>
            <span class="c1"># The initial conditions at rmin work. Stop here.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialConditions_rval</span><span class="p">(</span><span class="n">rmin</span><span class="p">,</span> <span class="n">phi_r0</span><span class="p">,</span> <span class="n">dphi_r0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">dphi_r0</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">delta_phi0</span><span class="p">):</span>
            <span class="c1"># The field is evolving in the wrong direction.</span>
            <span class="c1"># Increasing r0 won&#39;t increase |delta_phi_r0|/</span>
            <span class="k">return</span> <span class="n">rmin</span><span class="p">,</span> <span class="n">phi_r0</span><span class="p">,</span> <span class="n">dphi_r0</span>

        <span class="c1"># Find the smallest r0 such that delta_phi_r0 &gt; delta_phi_cutoff</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">rmin</span>
        <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
            <span class="n">rlast</span> <span class="o">=</span> <span class="n">r</span>
            <span class="n">r</span> <span class="o">*=</span> <span class="mi">10</span>
            <span class="n">phi</span><span class="p">,</span> <span class="n">dphi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exactSolution</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">phi0</span><span class="p">,</span> <span class="n">dV</span><span class="p">,</span> <span class="n">d2V</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">phi</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_absMin</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">delta_phi_cutoff</span><span class="p">):</span>
                <span class="k">break</span>

        <span class="c1"># Now find where phi - self.phi_absMin = delta_phi_cutoff exactly</span>

        <span class="k">def</span> <span class="nf">deltaPhiDiff</span><span class="p">(</span><span class="n">r_</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exactSolution</span><span class="p">(</span><span class="n">r_</span><span class="p">,</span> <span class="n">phi0</span><span class="p">,</span> <span class="n">dV</span><span class="p">,</span> <span class="n">d2V</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_absMin</span><span class="p">)</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="n">delta_phi_cutoff</span><span class="p">)</span>

        <span class="n">r0</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="n">deltaPhiDiff</span><span class="p">,</span> <span class="n">rlast</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">phi_r0</span><span class="p">,</span> <span class="n">dphi_r0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exactSolution</span><span class="p">(</span><span class="n">r0</span><span class="p">,</span> <span class="n">phi0</span><span class="p">,</span> <span class="n">dV</span><span class="p">,</span> <span class="n">d2V</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialConditions_rval</span><span class="p">(</span><span class="n">r0</span><span class="p">,</span> <span class="n">phi_r0</span><span class="p">,</span> <span class="n">dphi_r0</span><span class="p">)</span></div>

<div class="viewcode-block" id="SingleFieldInstanton.equationOfMotion"><a class="viewcode-back" href="../../tunnelling1D.html#cosmoTransitions.tunneling1D.SingleFieldInstanton.equationOfMotion">[docs]</a>    <span class="k">def</span> <span class="nf">equationOfMotion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Used to integrate the bubble wall.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dV</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">r</span><span class="p">])</span></div>

    <span class="n">_integrateProfile_rval</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span>
        <span class="s2">&quot;integrateProfile_rval&quot;</span><span class="p">,</span> <span class="s2">&quot;r y convergence_type&quot;</span><span class="p">)</span>
<div class="viewcode-block" id="SingleFieldInstanton.integrateProfile"><a class="viewcode-back" href="../../tunnelling1D.html#cosmoTransitions.tunneling1D.SingleFieldInstanton.integrateProfile">[docs]</a>    <span class="k">def</span> <span class="nf">integrateProfile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">dr0</span><span class="p">,</span>
                         <span class="n">epsfrac</span><span class="p">,</span> <span class="n">epsabs</span><span class="p">,</span> <span class="n">drmin</span><span class="p">,</span> <span class="n">rmax</span><span class="p">,</span> <span class="o">*</span><span class="n">eqn_args</span><span class="p">):</span>
        <span class="sd">R&quot;&quot;&quot;</span>
<span class="sd">        Integrate the bubble wall equation:</span>

<span class="sd">        .. math::</span>
<span class="sd">          \frac{d^2\phi}{dr^2} + \frac{\alpha}{r}\frac{d\phi}{dr} =</span>
<span class="sd">          \frac{dV}{d\phi}.</span>

<span class="sd">        The integration will stop when it either overshoots or undershoots</span>
<span class="sd">        the false vacuum minimum, or when it converges upon the false vacuum</span>
<span class="sd">        minimum.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        r0 : float</span>
<span class="sd">            The starting radius for the integration.</span>
<span class="sd">        y0 : array_like</span>
<span class="sd">            The starting values [phi(r0), dphi(r0)].</span>
<span class="sd">        dr0 : float</span>
<span class="sd">            The starting integration stepsize.</span>
<span class="sd">        epsfrac, epsabs : float</span>
<span class="sd">            The error tolerances used for integration. This is fed into</span>
<span class="sd">            :func:`helper_functions.rkqs` and is used to test for convergence.</span>
<span class="sd">        drmin : float</span>
<span class="sd">            The minimum allowed value of `dr` before raising an error.</span>
<span class="sd">        rmax : float</span>
<span class="sd">            The maximum allowed value of `r-r0` before raising an error.</span>
<span class="sd">        eqn_args : tuple</span>
<span class="sd">            Extra arguments to pass to :func:`equationOfMotion`. Useful for</span>
<span class="sd">            subclasses.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        r : float</span>
<span class="sd">            The final radius.</span>
<span class="sd">        y : array_like</span>
<span class="sd">            The final field values [phi, dphi]</span>
<span class="sd">        convergence_type : str</span>
<span class="sd">            Either &#39;overshoot&#39;, &#39;undershoot&#39;, or &#39;converged&#39;.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        helper_functions.IntegrationError</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dr</span> <span class="o">=</span> <span class="n">dr0</span>
        <span class="c1"># dY is the ODE that we use</span>
        <span class="k">def</span> <span class="nf">dY</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">args</span><span class="o">=</span><span class="n">eqn_args</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">equationOfMotion</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="n">dydr0</span> <span class="o">=</span> <span class="n">dY</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">r0</span><span class="p">)</span>
        <span class="n">ysign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">y0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_metaMin</span><span class="p">)</span>
            <span class="c1"># positive means we&#39;re heading down, negative means heading up.</span>
        <span class="n">rmax</span> <span class="o">+=</span> <span class="n">r0</span>

        <span class="n">convergence_type</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">dy</span><span class="p">,</span> <span class="n">dr</span><span class="p">,</span> <span class="n">drnext</span> <span class="o">=</span> <span class="n">rkqs</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">dydr0</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="n">dY</span><span class="p">,</span> <span class="n">dr</span><span class="p">,</span> <span class="n">epsfrac</span><span class="p">,</span> <span class="n">epsabs</span><span class="p">)</span>
            <span class="n">r1</span> <span class="o">=</span> <span class="n">r0</span> <span class="o">+</span> <span class="n">dr</span>
            <span class="n">y1</span> <span class="o">=</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">dy</span>
            <span class="n">dydr1</span> <span class="o">=</span> <span class="n">dY</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span><span class="n">r1</span><span class="p">)</span>

            <span class="c1"># Check for completion</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">r1</span> <span class="o">&gt;</span> <span class="n">rmax</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">IntegrationError</span><span class="p">(</span><span class="s2">&quot;r &gt; rmax&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">dr</span> <span class="o">&lt;</span> <span class="n">drmin</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">IntegrationError</span><span class="p">(</span><span class="s2">&quot;dr &lt; drmin&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_metaMin</span><span class="p">,</span><span class="mi">0</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">*</span><span class="n">epsabs</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="n">r</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">r1</span><span class="p">,</span><span class="n">y1</span>
                <span class="n">convergence_type</span> <span class="o">=</span> <span class="s2">&quot;converged&quot;</span>
                <span class="k">break</span>

            <span class="k">elif</span> <span class="n">y1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">ysign</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">y1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_metaMin</span><span class="p">)</span><span class="o">*</span><span class="n">ysign</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">cubicInterpFunction</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">dr</span><span class="o">*</span><span class="n">dydr0</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">dr</span><span class="o">*</span><span class="n">dydr1</span><span class="p">)</span>
                <span class="k">if</span><span class="p">(</span><span class="n">y1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">ysign</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="c1"># Extrapolate to where dphi(r) = 0</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">convergence_type</span> <span class="o">=</span> <span class="s2">&quot;undershoot&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Extrapolate to where phi(r) = phi_metaMin</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_metaMin</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">convergence_type</span> <span class="o">=</span> <span class="s2">&quot;overshoot&quot;</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">r0</span> <span class="o">+</span> <span class="n">dr</span><span class="o">*</span><span class="n">x</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="c1"># Advance the integration variables</span>
            <span class="n">r0</span><span class="p">,</span><span class="n">y0</span><span class="p">,</span><span class="n">dydr0</span> <span class="o">=</span> <span class="n">r1</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">dydr1</span>
            <span class="n">dr</span> <span class="o">=</span> <span class="n">drnext</span>
        <span class="c1"># Check convergence for a second time.</span>
        <span class="c1"># The extrapolation in overshoot/undershoot might have gotten us within</span>
        <span class="c1"># the acceptable error.</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_metaMin</span><span class="p">,</span><span class="mi">0</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">*</span><span class="n">epsabs</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="n">convergence_type</span> <span class="o">=</span> <span class="s2">&quot;converged&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_integrateProfile_rval</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">convergence_type</span><span class="p">)</span></div>

    <span class="n">profile_rval</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;Profile1D&quot;</span><span class="p">,</span> <span class="s2">&quot;R Phi dPhi Rerr&quot;</span><span class="p">)</span>
<div class="viewcode-block" id="SingleFieldInstanton.integrateAndSaveProfile"><a class="viewcode-back" href="../../tunnelling1D.html#cosmoTransitions.tunneling1D.SingleFieldInstanton.integrateAndSaveProfile">[docs]</a>    <span class="k">def</span> <span class="nf">integrateAndSaveProfile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">dr</span><span class="p">,</span>
                                <span class="n">epsfrac</span><span class="p">,</span> <span class="n">epsabs</span><span class="p">,</span><span class="n">drmin</span><span class="p">,</span> <span class="o">*</span><span class="n">eqn_args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Integrate the bubble profile, saving the output in an array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        R: array_like</span>
<span class="sd">            The array of points at which we want to save the profile.</span>
<span class="sd">        y0 : float</span>
<span class="sd">            The starting values [phi(r0), dphi(r0)].</span>
<span class="sd">        dr : float</span>
<span class="sd">            Starting stepsize.</span>
<span class="sd">        epsfrac, epsabs : float</span>
<span class="sd">            The error tolerances used for integration. This</span>
<span class="sd">            is fed into :func:`helper_functions.rkqs`.</span>
<span class="sd">        drmin : float</span>
<span class="sd">            The smallest allowed stepsize.</span>
<span class="sd">        eqn_args : tuple</span>
<span class="sd">            Extra arguments to pass to :func:`equationOfMotion`. Useful for</span>
<span class="sd">            subclasses.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        R, Phi, dPhi : array_like</span>
<span class="sd">            Radii and field values which make up the bubble profile.</span>
<span class="sd">        Rerr : float or None</span>
<span class="sd">            The first value of `r` at which ``dr &lt; drmin``, or `None` if</span>
<span class="sd">            ``dr &gt;= drmin`` always.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Subclasses can use this function without overriding it even if the</span>
<span class="sd">        subclass uses more fields/values in its equation of motion (i.e.,</span>
<span class="sd">        ``len(y0) &gt; 2``). This is accomplished by setting the class variable</span>
<span class="sd">        `profile_rval` to a different named tuple type with more than four</span>
<span class="sd">        inputs. The first three should always be *R, Phi, dPhi*, and the last</span>
<span class="sd">        one should be *Rerr*, but additional values can be stuck in between.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
        <span class="n">R</span><span class="p">,</span> <span class="n">r0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">R</span><span class="p">),</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Yout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">y0</span><span class="p">)))</span>
        <span class="n">Yout</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">y0</span>
        <span class="c1"># dY is the ODE that we use</span>
        <span class="k">def</span> <span class="nf">dY</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">args</span><span class="o">=</span><span class="n">eqn_args</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">equationOfMotion</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="n">dydr0</span> <span class="o">=</span> <span class="n">dY</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">r0</span><span class="p">)</span>
        <span class="n">Rerr</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">:</span>
            <span class="n">dy</span><span class="p">,</span> <span class="n">dr</span><span class="p">,</span> <span class="n">drnext</span> <span class="o">=</span> <span class="n">rkqs</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">dydr0</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="n">dY</span><span class="p">,</span> <span class="n">dr</span><span class="p">,</span> <span class="n">epsfrac</span><span class="p">,</span> <span class="n">epsabs</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dr</span> <span class="o">&gt;=</span> <span class="n">drmin</span><span class="p">):</span>
                <span class="n">r1</span> <span class="o">=</span> <span class="n">r0</span> <span class="o">+</span> <span class="n">dr</span>
                <span class="n">y1</span> <span class="o">=</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">dy</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">y1</span> <span class="o">=</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">dy</span><span class="o">*</span><span class="n">drmin</span><span class="o">/</span><span class="n">dr</span>
                <span class="n">dr</span> <span class="o">=</span> <span class="n">drnext</span> <span class="o">=</span> <span class="n">drmin</span>
                <span class="n">r1</span> <span class="o">=</span> <span class="n">r0</span> <span class="o">+</span> <span class="n">dr</span>
                <span class="k">if</span> <span class="n">Rerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">Rerr</span> <span class="o">=</span> <span class="n">r1</span>
            <span class="n">dydr1</span> <span class="o">=</span> <span class="n">dY</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span><span class="n">r1</span><span class="p">)</span>
            <span class="c1"># Fill the arrays, if necessary</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">r0</span> <span class="o">&lt;</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">r1</span><span class="p">):</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">cubicInterpFunction</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">dr</span><span class="o">*</span><span class="n">dydr0</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">dr</span><span class="o">*</span><span class="n">dydr1</span><span class="p">)</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="ow">and</span> <span class="n">r0</span> <span class="o">&lt;</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">r1</span><span class="p">):</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">r0</span><span class="p">)</span><span class="o">/</span><span class="n">dr</span>
                    <span class="n">Yout</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Advance the integration variables</span>
            <span class="n">r0</span><span class="p">,</span><span class="n">y0</span><span class="p">,</span><span class="n">dydr0</span> <span class="o">=</span> <span class="n">r1</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">dydr1</span>
            <span class="n">dr</span> <span class="o">=</span> <span class="n">drnext</span>

        <span class="n">rval</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="p">,)</span><span class="o">+</span><span class="nb">tuple</span><span class="p">(</span><span class="n">Yout</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">+</span><span class="n">eqn_args</span><span class="o">+</span><span class="p">(</span><span class="n">Rerr</span><span class="p">,)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_rval</span><span class="p">(</span><span class="o">*</span><span class="n">rval</span><span class="p">)</span></div>

<div class="viewcode-block" id="SingleFieldInstanton.findProfile"><a class="viewcode-back" href="../../tunnelling1D.html#cosmoTransitions.tunneling1D.SingleFieldInstanton.findProfile">[docs]</a>    <span class="k">def</span> <span class="nf">findProfile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xguess</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xtol</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="n">phitol</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span>
                    <span class="n">thinCutoff</span><span class="o">=.</span><span class="mi">01</span><span class="p">,</span> <span class="n">npoints</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">rmin</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="n">rmax</span><span class="o">=</span><span class="mi">1</span><span class="n">e4</span><span class="p">,</span>
                    <span class="n">max_interior_pts</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">R&quot;&quot;&quot;</span>
<span class="sd">        Calculate the bubble profile by iteratively over/undershooting.</span>

<span class="sd">        This will call :func:`integrateProfile` many times, trying to find</span>
<span class="sd">        the correct initial condition `phi(r=0)` such that the field ends up</span>
<span class="sd">        in the metastable vacuum at infinity. Once the correct initial</span>
<span class="sd">        condition is found, it calls :func:`integrateAndSaveProfile` to find</span>
<span class="sd">        the profile along the length of the wall.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xguess : float, optional</span>
<span class="sd">            The initial guess for `x`. If `None`, `xguess` is set such</span>
<span class="sd">            that ``phi_guess = self.phi_bar``.</span>
<span class="sd">        xtol : float, optional</span>
<span class="sd">            Target accuracy in `x`.</span>
<span class="sd">        phitol : float, optional</span>
<span class="sd">            Fractional error tolerance in integration.</span>
<span class="sd">        thinCutoff : float, optional</span>
<span class="sd">            Equal to `delta_phi_cutoff / (phi_metaMin - phi_absMin)`, where</span>
<span class="sd">            `delta_phi_cutoff` is used  in :func:`initialConditions`.</span>
<span class="sd">        npoints : int</span>
<span class="sd">            Number of points to return in the profile.</span>
<span class="sd">        rmin : float</span>
<span class="sd">            Relative to ``self.rscale``. Sets the smallest starting</span>
<span class="sd">            radius, the starting stepsize, and the smallest allowed stepsize</span>
<span class="sd">            (``0.01*rmin``).</span>
<span class="sd">        rmax : float</span>
<span class="sd">            Relative ``self.rscale``. Sets the maximum allowed integration</span>
<span class="sd">            distance.</span>
<span class="sd">        max_interior_pts : int</span>
<span class="sd">            Maximum number of points to place between ``r=0`` and the start of</span>
<span class="sd">            integration. If None, ``max_interior_pts=npoints/2``. If zero, no</span>
<span class="sd">            points are added to the bubble interior.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        R, Phi, dPhi : array_like</span>
<span class="sd">            Radii and field values which make up the bubble profile. Note that</span>
<span class="sd">            `R[0]` can be much bigger than zero for thin-walled bubbles.</span>
<span class="sd">        Rerr : float or None</span>
<span class="sd">            The first value of `r` at which ``dr &lt; drmin``, or `None` if</span>
<span class="sd">            ``dr &gt;= drmin`` always.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For very thin-walled bubbles, the initially value of `phi` can be</span>
<span class="sd">        extremely close to the stable minimum and small variations in `phi`</span>
<span class="sd">        can cause large variations in the integration. Rather than varying</span>
<span class="sd">        `phi(r=0)` directly, it is easier to vary a parameter `x` defined by</span>

<span class="sd">        .. math::</span>
<span class="sd">           \phi(r=0) = \phi_{\rm absMin}</span>
<span class="sd">           + e^{-x}(\phi_{\rm metaMin}-\phi_{\rm absMin})</span>

<span class="sd">        This way, `phi = phi_metaMin` when `x` is zero and</span>
<span class="sd">        `phi = phi_absMin` when `x` is  infinity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set x parameters</span>
        <span class="n">xmin</span> <span class="o">=</span> <span class="n">xtol</span><span class="o">*</span><span class="mi">10</span>
        <span class="n">xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">if</span> <span class="n">xguess</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">xguess</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">abs</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_bar</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_absMin</span><span class="p">)</span> <span class="o">/</span>
                            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_metaMin</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_absMin</span><span class="p">)))</span>
        <span class="n">xincrease</span> <span class="o">=</span> <span class="mf">5.0</span>
            <span class="c1"># The relative amount to increase x by if there is no upper bound.</span>
        <span class="c1"># --</span>
        <span class="c1"># Set r parameters</span>
        <span class="n">rmin</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rscale</span>
        <span class="n">dr0</span> <span class="o">=</span> <span class="n">rmin</span>
        <span class="n">drmin</span> <span class="o">=</span> <span class="mf">0.01</span><span class="o">*</span><span class="n">rmin</span>
        <span class="n">rmax</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rscale</span>
        <span class="c1"># --</span>
        <span class="c1"># Set the phi parameters</span>
        <span class="n">delta_phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_metaMin</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_absMin</span>
        <span class="n">epsabs</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">delta_phi</span><span class="p">,</span> <span class="n">delta_phi</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">rscale</span><span class="p">])</span><span class="o">*</span><span class="n">phitol</span><span class="p">)</span>
        <span class="n">epsfrac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">phitol</span>
        <span class="n">delta_phi_cutoff</span> <span class="o">=</span> <span class="n">thinCutoff</span> <span class="o">*</span> <span class="n">delta_phi</span>
            <span class="c1"># The sign for delta_phi_cutoff doesn&#39;t matter</span>
        <span class="c1"># --</span>
        <span class="n">integration_args</span> <span class="o">=</span> <span class="p">(</span><span class="n">dr0</span><span class="p">,</span> <span class="n">epsfrac</span><span class="p">,</span> <span class="n">epsabs</span><span class="p">,</span> <span class="n">drmin</span><span class="p">,</span> <span class="n">rmax</span><span class="p">)</span>
        <span class="n">rf</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">delta_phi0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">delta_phi</span>
            <span class="c1"># r0, phi0, dphi0 = self.initialConditions(x, rmin, thinCutoff)</span>
            <span class="n">r0_</span><span class="p">,</span> <span class="n">phi0</span><span class="p">,</span> <span class="n">dphi0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialConditions</span><span class="p">(</span>
                <span class="n">delta_phi0</span><span class="p">,</span> <span class="n">rmin</span><span class="p">,</span> <span class="n">delta_phi_cutoff</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">r0_</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="c1"># Use the last finite values instead</span>
                <span class="c1"># (assuming there are such values)</span>
                <span class="k">assert</span> <span class="n">rf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Failed to retrieve initial &quot;</span>\
                    <span class="s2">&quot;conditions on the first try.&quot;</span>
                <span class="k">break</span>
            <span class="n">r0</span> <span class="o">=</span> <span class="n">r0_</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">phi0</span><span class="p">,</span> <span class="n">dphi0</span><span class="p">])</span>
            <span class="n">rf</span><span class="p">,</span> <span class="n">yf</span><span class="p">,</span> <span class="n">ctype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">integrateProfile</span><span class="p">(</span><span class="n">r0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="o">*</span><span class="n">integration_args</span><span class="p">)</span>
            <span class="c1"># Check for overshoot, undershoot</span>
            <span class="k">if</span> <span class="n">ctype</span> <span class="o">==</span> <span class="s2">&quot;converged&quot;</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">ctype</span> <span class="o">==</span> <span class="s2">&quot;undershoot&quot;</span><span class="p">:</span>  <span class="c1"># x is too low</span>
                <span class="n">xmin</span> <span class="o">=</span> <span class="n">x</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="n">xincrease</span> <span class="k">if</span> <span class="n">xmax</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="k">else</span> <span class="o">.</span><span class="mi">5</span><span class="o">*</span><span class="p">(</span><span class="n">xmin</span><span class="o">+</span><span class="n">xmax</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ctype</span> <span class="o">==</span> <span class="s2">&quot;overshoot&quot;</span><span class="p">:</span>  <span class="c1"># x is too high</span>
                <span class="n">xmax</span> <span class="o">=</span> <span class="n">x</span>
                <span class="n">x</span> <span class="o">=</span> <span class="o">.</span><span class="mi">5</span><span class="o">*</span><span class="p">(</span><span class="n">xmin</span><span class="o">+</span><span class="n">xmax</span><span class="p">)</span>
            <span class="c1"># Check if we&#39;ve reached xtol</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">xmax</span><span class="o">-</span><span class="n">xmin</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">xtol</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="c1"># Integrate a second time, this time getting the points along the way</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">r0</span><span class="p">,</span> <span class="n">rf</span><span class="p">,</span> <span class="n">npoints</span><span class="p">)</span>
        <span class="n">profile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">integrateAndSaveProfile</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">dr0</span><span class="p">,</span>
                                               <span class="n">epsfrac</span><span class="p">,</span> <span class="n">epsabs</span><span class="p">,</span> <span class="n">drmin</span><span class="p">)</span>
        <span class="c1"># Make points interior to the bubble.</span>
        <span class="k">if</span> <span class="n">max_interior_pts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_interior_pts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">max_interior_pts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dx0</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">dx0</span> <span class="o">&lt;=</span> <span class="n">max_interior_pts</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">dx0</span><span class="p">)</span>
                <span class="n">R_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">max_interior_pts</span>
                <span class="c1"># R[0] = dx0 * (n + a*n*(n+1)/2)</span>
                <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">dx0</span> <span class="o">-</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">R_int</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">dx0</span><span class="o">*</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">N</span><span class="o">*</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">R_int</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># enforce this exactly</span>
            <span class="n">Phi_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">R_int</span><span class="p">)</span>
            <span class="n">dPhi_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">R_int</span><span class="p">)</span>
            <span class="n">Phi_int</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_absMin</span> <span class="o">+</span> <span class="n">delta_phi0</span>
            <span class="n">dPhi_int</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">dV</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dV_from_absMin</span><span class="p">(</span><span class="n">delta_phi0</span><span class="p">)</span>
            <span class="n">d2V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d2V</span><span class="p">(</span><span class="n">Phi_int</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">R_int</span><span class="p">)):</span>
                <span class="n">Phi_int</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dPhi_int</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exactSolution</span><span class="p">(</span>
                    <span class="n">R_int</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Phi_int</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dV</span><span class="p">,</span> <span class="n">d2V</span><span class="p">)</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">R_int</span><span class="p">,</span> <span class="n">profile</span><span class="o">.</span><span class="n">R</span><span class="p">)</span>
            <span class="n">Phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Phi_int</span><span class="p">,</span> <span class="n">profile</span><span class="o">.</span><span class="n">Phi</span><span class="p">)</span>
            <span class="n">dPhi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dPhi_int</span><span class="p">,</span> <span class="n">profile</span><span class="o">.</span><span class="n">dPhi</span><span class="p">)</span>
            <span class="n">profile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_rval</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">Phi</span><span class="p">,</span><span class="n">dPhi</span><span class="p">,</span> <span class="n">profile</span><span class="o">.</span><span class="n">Rerr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">profile</span></div>

<div class="viewcode-block" id="SingleFieldInstanton.findAction"><a class="viewcode-back" href="../../tunnelling1D.html#cosmoTransitions.tunneling1D.SingleFieldInstanton.findAction">[docs]</a>    <span class="k">def</span> <span class="nf">findAction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">profile</span><span class="p">):</span>
        <span class="sd">R&quot;&quot;&quot;</span>
<span class="sd">        Calculate the Euclidean action for the instanton:</span>

<span class="sd">        .. math::</span>
<span class="sd">          S = \int [(d\phi/dr)^2 + V(\phi)] r^\alpha dr d\Omega_\alpha</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        profile</span>
<span class="sd">            Output from :func:`findProfile()`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The Euclidean action.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">dphi</span> <span class="o">=</span> <span class="n">profile</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">profile</span><span class="o">.</span><span class="n">Phi</span><span class="p">,</span> <span class="n">profile</span><span class="o">.</span><span class="n">dPhi</span>
        <span class="c1"># Find the area of an n-sphere (alpha=n):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">+</span><span class="mi">1</span>  <span class="c1"># Number of dimensions in the integration</span>
        <span class="n">area</span> <span class="o">=</span> <span class="n">r</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">*</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="p">(</span><span class="n">d</span><span class="o">*.</span><span class="mi">5</span><span class="p">)</span><span class="o">/</span><span class="n">special</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="n">d</span><span class="o">*.</span><span class="mi">5</span><span class="p">)</span>
        <span class="c1"># And integrate the profile</span>
        <span class="n">integrand</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">dphi</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_metaMin</span><span class="p">)</span>
        <span class="n">integrand</span> <span class="o">*=</span> <span class="n">area</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">simps</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
        <span class="c1"># Find the bulk term in the bubble interior</span>
        <span class="n">volume</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="p">(</span><span class="n">d</span><span class="o">*.</span><span class="mi">5</span><span class="p">)</span><span class="o">/</span><span class="n">special</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="n">d</span><span class="o">*.</span><span class="mi">5</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">S</span> <span class="o">+=</span> <span class="n">volume</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">(</span><span class="n">phi</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_metaMin</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">S</span></div>

<div class="viewcode-block" id="SingleFieldInstanton.evenlySpacedPhi"><a class="viewcode-back" href="../../tunnelling1D.html#cosmoTransitions.tunneling1D.SingleFieldInstanton.evenlySpacedPhi">[docs]</a>    <span class="k">def</span> <span class="nf">evenlySpacedPhi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">dphi</span><span class="p">,</span> <span class="n">npoints</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fixAbs</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method takes `phi` and `dphi` as input, which will probably</span>
<span class="sd">        come from the output of :func:`findProfile`, and returns a different</span>
<span class="sd">        set of arrays `phi2` and `dphi2` such that `phi2` is linearly spaced</span>
<span class="sd">        (instead of `r`).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        phi, dphi : array_like</span>
<span class="sd">        npoints : int</span>
<span class="sd">            The number of points to output.</span>
<span class="sd">        k : int</span>
<span class="sd">            The degree of spline fitting. ``k=1`` means linear interpolation.</span>
<span class="sd">        fixAbs : bool</span>
<span class="sd">            If true, make phi go all the way to `phi_absMin`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fixAbs</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_absMin</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_metaMin</span><span class="p">))</span>
            <span class="n">dphi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dphi</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_metaMin</span><span class="p">)</span>
            <span class="n">dphi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dphi</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="c1"># Make sure that phi is increasing everywhere</span>
        <span class="c1"># (this is uglier than it ought to be)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">helper_functions</span><span class="o">.</span><span class="n">monotonicIndices</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
        <span class="c1"># Now do the interpolation</span>
        <span class="n">tck</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">splrep</span><span class="p">(</span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dphi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fixAbs</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_absMin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_metaMin</span><span class="p">,</span> <span class="n">npoints</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_metaMin</span><span class="p">,</span> <span class="n">npoints</span><span class="p">)</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">splev</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tck</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="n">dp</span></div></div>


<div class="viewcode-block" id="WallWithConstFriction"><a class="viewcode-back" href="../../tunnelling1D.html#cosmoTransitions.tunneling1D.WallWithConstFriction">[docs]</a><span class="k">class</span> <span class="nc">WallWithConstFriction</span><span class="p">(</span><span class="n">SingleFieldInstanton</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class solves a modified version of the instanton equations of motion</span>
<span class="sd">    with a *constant* friction term.</span>

<span class="sd">    This may be useful if one wants to estimate the shape of a bubble wall</span>
<span class="sd">    moving through a plasma. It will, however, be a rough estimate since a real</span>
<span class="sd">    friction force would most likely be field-dependent.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="WallWithConstFriction.findRScale"><a class="viewcode-back" href="../../tunnelling1D.html#cosmoTransitions.tunneling1D.WallWithConstFriction.findRScale">[docs]</a>    <span class="k">def</span> <span class="nf">findRScale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">R&quot;&quot;&quot;</span>
<span class="sd">        Find the characteristic length scale for tunneling over the potential</span>
<span class="sd">        barrier.</span>

<span class="sd">        Since for this class the tunneling solution always goes between the two</span>
<span class="sd">        minima, we want to take the overall shape between the two (not just</span>
<span class="sd">        at the top of the barrier) to set the radial scale. This finds the scale</span>
<span class="sd">        by fitting a simple quadratic to the potential.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        PotentialError</span>
<span class="sd">            when the barrier is non-existent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_absMin</span>
        <span class="n">pB</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_bar</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_metaMin</span><span class="p">)</span>
        <span class="n">pC</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_metaMin</span>
        <span class="n">yA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">(</span><span class="n">pA</span><span class="p">)</span>
        <span class="n">yB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">(</span><span class="n">pB</span><span class="p">)</span>
        <span class="n">yC</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">(</span><span class="n">pC</span><span class="p">)</span>
        <span class="c1"># Let lmda be the quadratic coefficient that will fit these 3 points</span>
        <span class="n">lmda</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">((</span><span class="n">yA</span><span class="o">-</span><span class="n">yB</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">pA</span><span class="o">-</span><span class="n">pB</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">yB</span><span class="o">-</span><span class="n">yC</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">pB</span><span class="o">-</span><span class="n">pC</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">pC</span><span class="o">-</span><span class="n">pA</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lmda</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">PotentialError</span><span class="p">(</span><span class="s2">&quot;Cannot fit the potential to a negative &quot;</span>
                                 <span class="s2">&quot;quadratic.&quot;</span><span class="p">,</span> <span class="s2">&quot;no barrier&quot;</span><span class="p">)</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lmda</span><span class="p">)</span>  <span class="c1"># frequency of oscillations</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">omega</span></div>

<div class="viewcode-block" id="WallWithConstFriction.initialConditions"><a class="viewcode-back" href="../../tunnelling1D.html#cosmoTransitions.tunneling1D.WallWithConstFriction.initialConditions">[docs]</a>    <span class="k">def</span> <span class="nf">initialConditions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">phi0_rel</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">R&quot;&quot;&quot;</span>
<span class="sd">        Get the initial conditions for integration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        F : float</span>
<span class="sd">            Magnitude of the friction term.</span>
<span class="sd">        phi0_rel : float</span>
<span class="sd">            The initial value for the field, relative to the two minima</span>
<span class="sd">            with 0.0 being at `phi_absMin` and 1.0 being at `phi_metaMin`</span>
<span class="sd">            (should be close to 0.0).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        r0, phi, dphi : float</span>
<span class="sd">            The initial radius and the field and its derivative at that radius.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Approximate the equation of motion near the minimum as</span>

<span class="sd">        .. math::</span>

<span class="sd">            \phi&#39;&#39; + F \phi&#39; = (\phi-\phi_{absMin}) \frac{d^2V}{d\phi^2}</span>

<span class="sd">        which has solution</span>

<span class="sd">        .. math::</span>

<span class="sd">            \phi(r) = (\phi_0-\phi_{absMin}) e^{kr} + \phi_{absMin}</span>

<span class="sd">        where :math:`k = (\sqrt{F^2 + 4 V&#39;&#39;} - F) / 2`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">F</span><span class="o">*</span><span class="n">F</span><span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">d2V</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_absMin</span><span class="p">))</span> <span class="o">-</span> <span class="n">F</span><span class="p">)</span>
        <span class="n">r0</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">phi0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_absMin</span> <span class="o">+</span> <span class="n">phi0_rel</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_metaMin</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_absMin</span><span class="p">)</span>
        <span class="n">dphi0</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="p">(</span><span class="n">phi0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_absMin</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialConditions_rval</span><span class="p">(</span><span class="n">r0</span><span class="p">,</span> <span class="n">phi0</span><span class="p">,</span> <span class="n">dphi0</span><span class="p">)</span></div>

<div class="viewcode-block" id="WallWithConstFriction.equationOfMotion"><a class="viewcode-back" href="../../tunnelling1D.html#cosmoTransitions.tunneling1D.WallWithConstFriction.equationOfMotion">[docs]</a>    <span class="k">def</span> <span class="nf">equationOfMotion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">F</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Used to integrate the bubble wall.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dV</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="n">F</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span></div>

    <span class="n">profile_rval</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;Profile1D&quot;</span><span class="p">,</span> <span class="s2">&quot;R Phi dPhi F Rerr&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="WallWithConstFriction.findProfile"><a class="viewcode-back" href="../../tunnelling1D.html#cosmoTransitions.tunneling1D.WallWithConstFriction.findProfile">[docs]</a>    <span class="k">def</span> <span class="nf">findProfile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Fguess</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Ftol</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="n">phitol</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span>
                    <span class="n">npoints</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">rmin</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="n">rmax</span><span class="o">=</span><span class="mi">1</span><span class="n">e4</span><span class="p">,</span> <span class="n">phi0_rel</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">R&quot;&quot;&quot;</span>
<span class="sd">        Calculate the bubble profile by iteratively over/undershooting.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Fguess : float, optional</span>
<span class="sd">            The initial guess for `F`. If `None`, `Fguess` is calculated from</span>
<span class="sd">            `self.rscale`.</span>
<span class="sd">        Ftol : float, optional</span>
<span class="sd">            Target accuracy in `F`, relative to `Fguess`.</span>
<span class="sd">        phitol : float, optional</span>
<span class="sd">            Fractional error tolerance in integration.</span>
<span class="sd">        npoints : int</span>
<span class="sd">            Number of points to return in the profile.</span>
<span class="sd">        rmin : float</span>
<span class="sd">            Relative to ``self.rscale``. Sets the smallest starting</span>
<span class="sd">            radius, the starting stepsize, and the smallest allowed stepsize</span>
<span class="sd">            (``0.01*rmin``).</span>
<span class="sd">        rmax : float</span>
<span class="sd">            Relative ``self.rscale``. Sets the maximum allowed integration</span>
<span class="sd">            distance.</span>
<span class="sd">        phi0_rel : float</span>
<span class="sd">            Passed to :func:`initialConditions`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        R, Phi, dPhi : array_like</span>
<span class="sd">            Radii and field values which make up the bubble profile. Note that</span>
<span class="sd">            `R[0]` can be much bigger than zero for thin-walled bubbles.</span>
<span class="sd">        Rerr : float or None</span>
<span class="sd">            The first value of `r` at which ``dr &lt; drmin``, or `None` if</span>
<span class="sd">            ``dr &gt;= drmin`` always.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set r parameters</span>
        <span class="n">rmin</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rscale</span>
        <span class="n">dr0</span> <span class="o">=</span> <span class="n">rmin</span>
        <span class="n">drmin</span> <span class="o">=</span> <span class="mf">0.01</span><span class="o">*</span><span class="n">rmin</span>
        <span class="n">rmax</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rscale</span>
        <span class="c1"># --</span>
        <span class="c1"># Set the phi parameters</span>
        <span class="n">delta_phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_metaMin</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_absMin</span>
        <span class="n">epsabs</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">delta_phi</span><span class="p">,</span> <span class="n">delta_phi</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">rscale</span><span class="p">])</span><span class="o">*</span><span class="n">phitol</span><span class="p">)</span>
        <span class="n">epsfrac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">phitol</span>
        <span class="c1"># --</span>
        <span class="c1"># Set F parameters</span>
        <span class="n">Fmin</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">Fmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">if</span> <span class="n">Fguess</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">F</span> <span class="o">=</span> <span class="n">Fguess</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Find F from conservation of energy</span>
            <span class="c1"># (total work done to slow down the field)</span>
            <span class="n">Delta_V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_metaMin</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_absMin</span><span class="p">)</span>
            <span class="n">F</span> <span class="o">=</span> <span class="n">Delta_V</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rscale</span> <span class="o">/</span> <span class="n">delta_phi</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">Ftol</span> <span class="o">*=</span> <span class="n">F</span>
        <span class="n">Fincrease</span> <span class="o">=</span> <span class="mf">5.0</span>
            <span class="c1"># The relative amount to increase F by if there is no upper bound.</span>
        <span class="c1"># --</span>
        <span class="n">integration_args</span> <span class="o">=</span> <span class="p">[</span><span class="n">dr0</span><span class="p">,</span> <span class="n">epsfrac</span><span class="p">,</span> <span class="n">epsabs</span><span class="p">,</span> <span class="n">drmin</span><span class="p">,</span> <span class="n">rmax</span><span class="p">,</span> <span class="n">F</span><span class="p">]</span>
        <span class="n">rf</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">r0</span><span class="p">,</span> <span class="n">phi0</span><span class="p">,</span> <span class="n">dphi0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialConditions</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">phi0_rel</span><span class="p">)</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">phi0</span><span class="p">,</span> <span class="n">dphi0</span><span class="p">])</span>
            <span class="n">integration_args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">F</span>
            <span class="n">rf</span><span class="p">,</span> <span class="n">yf</span><span class="p">,</span> <span class="n">ctype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">integrateProfile</span><span class="p">(</span><span class="n">r0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="o">*</span><span class="n">integration_args</span><span class="p">)</span>
            <span class="c1"># Check for overshoot, undershoot</span>
            <span class="k">if</span> <span class="n">ctype</span> <span class="o">==</span> <span class="s2">&quot;converged&quot;</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">ctype</span> <span class="o">==</span> <span class="s2">&quot;undershoot&quot;</span><span class="p">:</span>  <span class="c1"># F is too high</span>
                <span class="n">Fmax</span> <span class="o">=</span> <span class="n">F</span>
                <span class="n">F</span> <span class="o">=</span> <span class="n">F</span><span class="o">/</span><span class="n">Fincrease</span> <span class="k">if</span> <span class="n">Fmin</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="k">else</span> <span class="o">.</span><span class="mi">5</span><span class="o">*</span><span class="p">(</span><span class="n">Fmin</span><span class="o">+</span><span class="n">Fmax</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ctype</span> <span class="o">==</span> <span class="s2">&quot;overshoot&quot;</span><span class="p">:</span>  <span class="c1"># F is too low</span>
                <span class="n">Fmin</span> <span class="o">=</span> <span class="n">F</span>
                <span class="n">F</span> <span class="o">=</span> <span class="n">F</span><span class="o">*</span><span class="n">Fincrease</span> <span class="k">if</span> <span class="n">Fmax</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="k">else</span> <span class="o">.</span><span class="mi">5</span><span class="o">*</span><span class="p">(</span><span class="n">Fmin</span><span class="o">+</span><span class="n">Fmax</span><span class="p">)</span>
            <span class="c1"># Check if we&#39;ve reached xtol</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">Fmax</span><span class="o">-</span><span class="n">Fmin</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">Ftol</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="c1"># Integrate a second time, this time getting the points along the way</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">r0</span><span class="p">,</span> <span class="n">rf</span><span class="p">,</span> <span class="n">npoints</span><span class="p">)</span>
        <span class="n">profile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">integrateAndSaveProfile</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">dr0</span><span class="p">,</span>
                                               <span class="n">epsfrac</span><span class="p">,</span> <span class="n">epsabs</span><span class="p">,</span> <span class="n">drmin</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">profile</span></div>

<div class="viewcode-block" id="WallWithConstFriction.findAction"><a class="viewcode-back" href="../../tunnelling1D.html#cosmoTransitions.tunneling1D.WallWithConstFriction.findAction">[docs]</a>    <span class="k">def</span> <span class="nf">findAction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">profile</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Always returns `np.inf`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">CosmoTransitions 2.0.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2014, Carroll L. Wainwright.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.1.
    </div>
  </body>
</html>